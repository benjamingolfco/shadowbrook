name: Shadowbrook Implementation

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to dispatch for sprint execution'
        required: true
        type: string
  pull_request:
    types: [opened, closed, synchronize]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  schedule:
    - cron: '0 */2 * * *'  # Every 2 hours

jobs:
  # ──────────────────────────────────────────────────────────────────────
  # Cron dispatcher — finds all unblocked sprint issues and triggers
  # a separate workflow_dispatch run for each (parallel execution).
  # ──────────────────────────────────────────────────────────────────────
  find-work:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      actions: write
      id-token: write
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Find and dispatch unblocked sprint issues
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          echo "::group::Querying project for Ready issues in current iteration"

          # Server-side filter: only Ready issues in the current iteration
          ITEMS=$(gh api graphql -f query='
            query {
              organization(login: "benjamingolfco") {
                projectV2(number: 1) {
                  items(first: 100, query: "status:Ready iteration:@current") {
                    nodes {
                      content {
                        ... on Issue { number state }
                      }
                    }
                  }
                }
              }
            }
          ')

          echo "::endgroup::"

          # Extract open issue numbers (filter out closed/PRs)
          READY_ISSUES=$(echo "$ITEMS" | jq -r '
            .data.organization.projectV2.items.nodes[]
            | select(.content.number != null)
            | select(.content.state == "OPEN")
            | .content.number
          ')

          if [ -z "$READY_ISSUES" ]; then
            echo "No Ready issues in current iteration."
            exit 0
          fi

          echo "Ready issues in current iteration: $READY_ISSUES"

          # Check dependencies for each — dispatch only unblocked ones
          DISPATCHED=0
          for ISSUE_NUM in $READY_ISSUES; do
            echo "::group::Checking dependencies for #$ISSUE_NUM"

            BLOCKERS=$(gh api "repos/benjamingolfco/shadowbrook/issues/$ISSUE_NUM/dependencies/blocked_by" 2>/dev/null || echo '[]')
            OPEN_BLOCKERS=$(echo "$BLOCKERS" | jq '[.[] | select(.state == "open")] | length')

            if [ "$OPEN_BLOCKERS" -gt 0 ]; then
              echo "#$ISSUE_NUM is blocked by $OPEN_BLOCKERS open issue(s) — skipping"
            else
              echo "#$ISSUE_NUM is unblocked — dispatching"
              gh workflow run claude-implementation.yml \
                --repo benjamingolfco/shadowbrook \
                -f issue_number="$ISSUE_NUM"
              DISPATCHED=$((DISPATCHED + 1))
            fi

            echo "::endgroup::"
          done

          echo "Dispatched $DISPATCHED issue(s) for sprint execution."

  # ──────────────────────────────────────────────────────────────────────
  # Sprint execution — handles one issue (workflow_dispatch) or
  # one PR/CI/review event. Each issue runs in its own concurrency group.
  # ──────────────────────────────────────────────────────────────────────
  sprint:
    if: github.event_name != 'schedule'
    concurrency:
      group: sprint-${{ inputs.issue_number || github.event.pull_request.number || github.event.check_suite.id || 'event' }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for branch creation

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Run Sprint Manager
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ steps.app-token.outputs.token }}
          allowed_bots: "benjamingolfco-claude-agent[bot]"
          show_full_output: true
          additional_permissions: |
            actions: write
          claude_args: |
            --model claude-sonnet-4-5-20250929 --allowedTools "Bash" "Read" "Write" "Edit" "Glob" "Grep" "Task"
          prompt: |
            You are the Sprint Manager for the Shadowbrook agent pipeline.

            ## Context
            Event: ${{ github.event_name }}
            Action: ${{ github.event.action || 'N/A' }}
            Issue Number: ${{ inputs.issue_number || 'N/A' }}
            Run ID: ${{ github.run_id }}
            Run Link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            ## Instructions
            1. Read `.claude/agents/sprint-manager.md` for your role definition, dispatch logic, and status IDs.
            2. Read `.claude/skills/agent-pipeline/SKILL.md` for pipeline protocols and comment format.
            3. Analyze the triggering event and take appropriate action.

            ## Event Handling

            ### workflow_dispatch (issue dispatch)
            Issue Number is provided above. This is a sprint dispatch for a specific issue.
            - Read the issue and its Issue Plan comment
            - Run the full sprint flow: Architect detailed plan → implementation agents → PR
            - See sprint-manager.md § Per-Issue Sprint Flow

            ### pull_request:closed (merged)
            - Find the linked issue from the PR body or branch name
            - Verify the issue is marked Done
            - Query what this issue was blocking (merge cascade)
            - For each newly-unblocked sprint issue, trigger a new dispatch:
              `gh workflow run claude-implementation.yml -f issue_number={N}`
            - Update Current Sprint Overview

            ### pull_request:opened / pull_request:synchronize
            - Check if the PR is linked to a sprint issue (has `agentic` label)
            - If not a sprint PR, skip entirely
            - If sprint PR, update status as needed

            ### pull_request_review:submitted
            - Check if the PR has the `agentic` label; skip if not
            - If review passes (comment, no request-changes): set Ready to Merge, tag owner
            - If review requests changes: re-dispatch implementation agent with feedback

            ### check_suite:completed
            - Check if the PR is linked to a sprint issue
            - If CI passes: set In Review
            - If CI fails: re-dispatch implementation agent with failure details

            ## Spawning Agents
            When spawning agents (architect, backend, frontend, devops):

            1. Gather all issue context the agent needs.
            2. Spawn the agent using the Task tool with appropriate subagent_type.
               In the Task prompt, include:
               - All issue context (paste it — agent should not need GitHub API calls)
               - For Architect: instruct for DETAILED implementation plan (file-by-file, test strategy)
               - For implementation agents: include the Architect's detailed plan and specific Dev Task items
               - Tell implementation agents to work on the current branch, commit, and push
               - Tell agents NOT to create branches or PRs
               - Do NOT include SKILL.md — agents don't need pipeline protocol
            3. When the agent returns:
               - Format and post handback comment (role icon, run link footer)
               - Update Issue Plan comment
               - Check off completed Dev Task items
               - Advance to next phase

            ## PR Creation
            After all implementation agents complete:
            - Create PR with `gh pr create --label agentic`
            - Include "Closes #{issue_number}" in the body
            - Set status to CI Pending

            ## Dispatching Parallel Work
            When you discover newly-unblocked issues (e.g., during merge cascade),
            trigger a separate workflow run for each:
            ```
            gh workflow run claude-implementation.yml --repo benjamingolfco/shadowbrook -f issue_number={N}
            ```
            This runs each issue in its own parallel workflow.

            ## General
            - Use Explore subagents (Task with subagent_type "Explore") for verbose context gathering.
            - Use the Run ID and Run Link above in all comment footers — never read environment variables for these.
            - Skip PRs without the `agentic` label (owner's manual PRs).
